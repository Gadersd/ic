use crate::unrust::{parse::*, global::*, core::*};
use crate::parser::{self, Node, Constructor, Duplicator, Alphanumeric, Redex, Book};
use crate::numeric::{self, Operator};

use std::collections::HashMap;
use std::collections::BTreeSet;

#[derive(Debug, Clone)]
pub struct Dup {
    pub original_var: String, 
    pub duplicate_1: String, 
    pub duplicate_2: String, 
}

impl Dup {
    pub fn into_redex(self) -> Redex {
        let duplicator = parser::Duplicator {
            a: Node::Variable(self.duplicate_1.into()), 
            b: Node::Variable(self.duplicate_2.into()), 
        };
        Redex {
            tree_1: Node::Variable(self.original_var.into()), 
            tree_2: duplicator.into(), 
        }
    }
}

/// Ensures compatibility with global scope and affine restrictions for local variables
#[derive(Debug)]
pub struct GlobalAffineProgram<E> {
    pub program: Program<E>, 
    pub namer: UniqueNamer,
    pub dups: HashMap<String, Vec<Dup>>, 
    pub main_rename: String, 
}

impl GlobalAffineProgram<CoreExpression> {
    pub fn from_global_program(program: GlobalProgram<CoreExpression>) -> Self {
        let function_names: BTreeSet<String> = program.program.functions.iter().map(|(name, _)| name.clone()).collect();

        let mut functions = HashMap::new();
        let mut dups = HashMap::new();
        let mut namer = program.namer;

        for (func_name, function) in program.program.functions {
            let (function, local_dups) = Self::make_function_affine(function, &function_names, &mut namer);

            functions.insert(func_name.clone(), function);
            dups.insert(func_name, local_dups);
        }

        let structs = program.program.structs;
        let enums = program.program.enums;

        GlobalAffineProgram {
            program: Program {
                functions, 
                structs, 
                enums, 
            }, 
            namer: namer, 
            dups: dups, 
            main_rename: program.main_rename, 
        }
    }

    fn make_function_affine(function: Function<CoreExpression>, function_names: &BTreeSet<String>, mut namer: &mut UniqueNamer) -> (Function<CoreExpression>, Vec<Dup>) {
        // count the number of local variable consumes
        let count_consumes = |var: Variable, usage, mut consume_count: HashMap<String, usize>| {
            match usage {
                VarUsage::Introduce => {
                    (var, consume_count)
                }, 
                VarUsage::Consume => {
                    // only local variables need duplicates
                    if !function_names.contains(var.name.as_str()) {
                        let count = consume_count.get(var.name.as_str()).cloned().unwrap_or(0);
                        consume_count.insert(var.name.clone().into_string(), count + 1);
                    }
                    
                    (var, consume_count)
                }, 
            }
        };

        let (function, _, var_consume_counts) = function.map_vars(|v, u, ctx, gctx| {
                let (v, gctx) = count_consumes(v, u, gctx);
                (v, ctx, gctx)
            }, 
            (), 
            HashMap::<String, usize>::new()
        );

        // must substitute old vars with new ones generated by duplicators
        let var_replacements: HashMap<String, Vec<String>> = var_consume_counts.into_iter().map(|(var, consume_count)| {
            let var_list = (0..consume_count - 1).into_iter().map(|_| namer.get_unique_name()).collect();

            (var, var_list)
        }).collect();

        // generate duplicators
        let dups: Vec<_> = var_replacements.iter().filter(|(_, rep_list)| rep_list.len() >= 2).flat_map(|(var, rep_list)| {
            let mut dummy_var = var.clone();
            let mut dups: Vec<_> = rep_list.iter().take(rep_list.len() - 2).map(|var| {
                let new_dummy_var = namer.get_unique_name();
                let dup = Dup {
                    original_var: dummy_var.clone(), 
                    duplicate_1: var.clone(), 
                    duplicate_2: new_dummy_var.clone(), 
                };
                dummy_var = new_dummy_var;
                dup
            }).collect();

            dups.push(
                Dup {
                    original_var: dummy_var.clone(), 
                    duplicate_1: rep_list[rep_list.len() - 2].clone(), 
                    duplicate_2: rep_list[rep_list.len() - 1].clone(), 
                }
            );

            dups
        }).collect();

        // substitute vars
        let perform_substitution = |mut var: Variable, usage, mut var_substitutions: HashMap<String, Vec<String>>| {
            match usage {
                VarUsage::Introduce => {
                    (var, var_substitutions)
                }, 
                VarUsage::Consume => {
                    if let Some(subs) = var_substitutions.get_mut(var.name.as_str()) {
                        if let Some(new_name) = subs.pop() {
                            var.name = new_name.into();
                        }
                    }
                    
                    (var, var_substitutions)
                }, 
            }
        };

        let (function, _, _) = function.map_vars(|v, u, ctx, gctx| {
                let (v, gctx) = perform_substitution(v, u, gctx);
                (v, ctx, gctx)
            }, 
            (), 
            var_replacements
        );

        (function, dups)
    }

    pub fn is_var_global(&self, var: &str) -> bool {
        self.program.functions.contains_key(var)
    }

    pub fn new_var_name(&mut self) -> Name {
        self.namer.get_unique_name().into()
    }

    pub fn transpile_to_node(mut self) -> parser::Program {
        let mut books: Vec<_> = self.program.functions.clone().into_iter().map(|(f_name, function)| {
            let mut redexes: Vec<_> = self.dups.get(f_name.as_str()).unwrap().iter().map(|dup| dup.clone().into_redex()).collect();
            
            let func_out = self._transpile_to_node(function.clone().block.into(), &mut redexes);

            let mut node = func_out;
            for param in &function.parameters {
                node = Node::Construct(
                    Constructor {
                        a: Node::Variable(param.name.clone().into_string().into()), 
                        b: node
                    }.into()
                );
            }

            let name = function.name.clone().into_string().into();
            let net = parser::Net {
                tree: node, 
                redexes: redexes, 
            };

            Book {
                name,  
                net, 
            }
        }).collect();

        let main_book_idx = books.iter().enumerate().find(|(_, book)| book.name.as_str() == self.main_rename.as_str()).map(|(i, _)| i).unwrap();
        let main = books.remove(main_book_idx);

        parser::Program {
            main: main, 
            others: books, 
        }
    }

    fn _transpile_to_node(&mut self, expr: CoreExpression, redexes: &mut Vec<Redex>) -> Node {
        match expr {
            CoreExpression::Lambda(lambda) => {
                let block = self._transpile_to_node(lambda.block.into(), redexes);

                // build up parameters
                let mut node = block;
                for param in lambda.parameters.iter().rev() {
                    node = Node::Construct(
                        Constructor {
                            a: Node::Variable(param.name.clone().into_string().into()), 
                            b: node, 
                        }.into()
                    );
                }

                node
            }, 
            CoreExpression::Variable(v) => {
                if self.is_var_global(v.name.as_str()) {
                    Node::Reference(v.name.into_string().into())
                } else {
                    Node::Variable(v.name.into_string().into())
                }
            }, 
            CoreExpression::Number(n) => {
                let var_name = self.new_var_name();
                let var = parser::Node::Variable(var_name.clone().into_string().into());
    
                let num = parser::Node::Numeric(parser::Numeric::Number(parser::Number {
                    n: n.native_num.to_string().into(), 
                    native_num: match n.native_num {
                        NativeNumber::U24(n) => numeric::Number::U24(n), 
                        NativeNumber::I24(n) => numeric::Number::I24(n), 
                        NativeNumber::F24(n) => numeric::Number::F24(n), 
                    }, 
                }));
    
                let redex = Redex {
                    tree_1: var, 
                    tree_2: num, 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
             }, 
             CoreExpression::Char(ch) => {
                let var_name = self.new_var_name();
                let var = parser::Node::Variable(var_name.clone().into_string().into());
    
                let num = parser::Node::Numeric(parser::Numeric::Number(parser::Number {
                    n: ch.ch.clone().into(), 
                    native_num: numeric::Number::U24(ch.ch.chars().nth(0).unwrap() as u32), 
                }));
    
                let redex = Redex {
                    tree_1: var, 
                    tree_2: num, 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
            }, 
            /*CoreExpression::String(s) => {
    
            }, */
            CoreExpression::Operation(op) => {
                let left_expr_output = self._transpile_to_node(op.expression_left, redexes);
                let right_expr_output = self._transpile_to_node(op.expression_right, redexes);
    
                let var_name = self.new_var_name();
                let output_var = parser::Node::Variable(var_name.clone().into_string().into());
    
                let operator = parser::Numeric::Sym(parser::Symbol {
                    op: op.operator, 
                });
    
                let operate1 = parser::Operate {
                    a: right_expr_output, 
                    b: output_var, 
                };
    
                let operate2 = parser::Operate {
                    a: operator.into(), 
                    b: operate1.into(), 
                };
    
                let redex = Redex {
                    tree_1: left_expr_output, 
                    tree_2: operate2.into(), 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
            }, 
            CoreExpression::Tuple(tuple) => {
                let var_name = self.new_var_name();
                let var = parser::Node::Variable(var_name.clone().into_string().into());
    
                let mut node = var.clone();
                for elem in tuple.elements {
                    let expr = self._transpile_to_node(elem, redexes);
    
                    node = Node::Construct(
                        Constructor {
                            a: expr, 
                            b: node, 
                        }.into()
                    )
                }
    
                node = Node::Construct(
                    Constructor {
                        a: node, 
                        b: var, 
                    }.into()
                );
    
                let var_name = self.new_var_name();
    
                let redex = Redex {
                    tree_1: node, 
                    tree_2: parser::Node::Variable(var_name.clone().into_string().into()), 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
            }, 
            CoreExpression::TupleAccess(ta) => {
                // build selector
                let var_name = self.new_var_name();
                let builder_out = parser::Node::Variable(var_name.clone().into_string().into());
    
                let mut node = builder_out.clone();
                for i in (0..ta.len).into_iter().rev() {
                    let left_part = if i != ta.index {Node::Eraser} else {builder_out.clone()};
                    node = Node::Construct(
                        Constructor {
                            a: left_part, 
                            b: node, 
                        }.into(), 
                    );
                }
    
                let var_name = self.new_var_name();
                let output = parser::Node::Variable(var_name.clone().into_string().into());
    
                let call_node = Node::Construct(
                    Constructor {
                        a: node, 
                        b: output, 
                    }.into()
                );
    
                let expr = self._transpile_to_node(ta.expression, redexes);
    
                let redex = Redex {
                    tree_1: call_node, 
                    tree_2: expr, 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
            }, 
            CoreExpression::BinarySwitch(bswitch) => {
                let var_name = self.new_var_name();
                let output_var = parser::Node::Variable(var_name.clone().into_string().into());

                let condition = self._transpile_to_node(bswitch.condition, redexes);

                // ignores the first argument (n - 1)
                let pass = self._transpile_to_node(bswitch.pass.into(), redexes);
                let pass = Node::Construct(
                    parser::Constructor {
                        a: parser::Node::Eraser, 
                        b: pass, 
                    }.into()
                );
                
                let fail = self._transpile_to_node(bswitch.fail.into(), redexes);

                let pair = Node::Construct(
                    parser::Constructor {
                        a: fail, 
                        b: pass, 
                    }.into()
                );


                let switch = Node::Switch(
                    parser::Switch {
                        a: pair, 
                        b: output_var, 
                    }.into()
                );

                let redex = Redex {
                    tree_1: condition, 
                    tree_2: switch, 
                };
    
                redexes.push(redex);

                Node::Variable( var_name.into_string().into() )
            }, 
            /*CoreExpression::IfElse(if_else) => {
                let condition = self._transpile_to_node(if_else.condition, redexes);
                let block_pass = self._transpile_to_node(if_else.block_pass.into(), redexes);
                let block_fail = self._transpile_to_node(if_else.block_fail.into(), redexes);
    
                let var_name = self.new_var_name();
                let output_var = parser::Node::Variable(var_name.clone().into_string().into());
    
                let pass_fail_node = Node::Construct(
                    Constructor {
                        a: block_fail, 
                        b: block_pass, 
                    }.into()
                );
    
                let cond_node = Node::Switch(
                    parser::Switch {
                        a: pass_fail_node, 
                        b: output_var, 
                    }.into()
                );
    
                let redex = Redex {
                    tree_1: condition, 
                    tree_2: cond_node, 
                };
    
                redexes.push(redex);
                Node::Variable( var_name.into_string().into() )
            }, */
            CoreExpression::Block(block) => {
                for sv in block.statements {
                    let expr = self._transpile_to_node(sv.value, redexes);
                    let redex = Redex {
                        tree_1: Node::Variable(sv.var.name.clone().into_string().into()), 
                        tree_2: expr, 
                    };

                    redexes.push(redex);
                }

                let output = self._transpile_to_node(block.expression, redexes);
                output
            }, 
            CoreExpression::Call(call) => {
                let func = self._transpile_to_node(call.expression, redexes);
                let args: Vec<_> = call.arguments.into_iter().map(|arg| self._transpile_to_node(arg, redexes)).collect();
    
                if !args.is_empty() {
                    let var_name = self.new_var_name();
                    let output_var = parser::Node::Variable(var_name.clone().into_string().into());
                
                    let mut node = output_var;
                    for arg in args.into_iter().rev() {
                        node = parser::Node::Construct(
                            Constructor {
                                a: arg, 
                                b: node, 
                            }.into()
                        );
                    }
    
                    let redex = Redex {
                        tree_1: func, 
                        tree_2: node, 
                    };
    
                    redexes.push(redex);
                    Node::Variable( var_name.into_string().into() )
                } else {
                    func
                }
            }, 
        }
    }
}

